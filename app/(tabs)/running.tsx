// RunningScreen.tsx
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Location from 'expo-location';
import * as ImagePicker from 'expo-image-picker';
import React, { useEffect, useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Modal,
  Platform,
  ScrollView,
  StatusBar,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
  Image,
} from 'react-native';
import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context';
import MapView, { Marker, Polyline, PROVIDER_GOOGLE } from '../../components/ui/MapShim';
import type { MapEvent } from '../../components/ui/MapShim';
import { router } from 'expo-router';

/* =========================================================================
   üîó Map & Route API Ïú†Ìã∏
   ========================================================================= */
const BASE_URL = 'https://www.shallwewalk.kro.kr';

type Meta = { total_count: number; pageable_count: number; is_end: boolean };

function qs(params: Record<string, any>) {
  const sp = new URLSearchParams();
  for (const [k, v] of Object.entries(params)) {
    if (v === undefined || v === null || v === '') continue;
    sp.set(k, String(v));
  }
  return sp.toString();
}

async function get<T>(path: string, params: Record<string, any> = {}, timeoutMs = 8000): Promise<T> {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);
  const url = `${BASE_URL}${path}${Object.keys(params).length ? `?${qs(params)}` : ''}`;

  // ‚úÖ ÌÜ†ÌÅ∞Ïù¥ ÏûàÏúºÎ©¥ Authorization Ìó§ÎçîÎ°úÎèÑ Î≥¥ÎÉÑ(Ïø†ÌÇ§ Î∞±ÏóÖ)
  const token = await AsyncStorage.getItem('authToken').catch(() => null);
  const res = await fetch(url, {
    method: 'GET',
    credentials: 'include',
    headers: token ? { Authorization: `Bearer ${token}` } : undefined,
    signal: controller.signal,
  });
  clearTimeout(t);
  if (!res.ok) {
    const msg = await res.text().catch(() => '');
    throw new Error(`[GET ${path}] ${res.status} ${msg}`);
  }
  return res.json();
}

async function post<T>(path: string, body: any, timeoutMs = 10000): Promise<T> {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);
  const url = `${BASE_URL}${path}`;

  // ‚úÖ ÌÜ†ÌÅ∞Ïù¥ ÏûàÏúºÎ©¥ Authorization Ìó§ÎçîÎ°úÎèÑ Î≥¥ÎÉÑ(Ïø†ÌÇ§ Î∞±ÏóÖ)
  const token = await AsyncStorage.getItem('authToken').catch(() => null);
  const headers: Record<string, string> = { 'Content-Type': 'application/json' };
  if (token) headers.Authorization = `Bearer ${token}`;

  const res = await fetch(url, {
    method: 'POST',
    credentials: 'include',
    headers,
    body: JSON.stringify(body),
    signal: controller.signal,
  });
  clearTimeout(t);
  if (!res.ok) {
    const msg = await res.text().catch(() => '');
    throw new Error(`[POST ${path}] ${res.status} ${msg}`);
  }
  return res.json();
}

// 1) /api/map/region/by-coord
export type RegionDoc = {
  region_type: string;
  address_name: string;
  region_1depth_name: string;
  region_2depth_name: string;
  region_3depth_name: string;
  region_4depth_name: string;
  code: string;
  x: number | string;
  y: number | string;
};
type RegionByCoordRes = { meta: Meta; documents: RegionDoc[] };
async function apiRegionByCoord(params: {
  x: number; // lon
  y: number; // lat
  inputCoord?: 'WGS84' | string;
  outputCoord?: 'WGS84' | string;
}) {
  const { inputCoord = 'WGS84', outputCoord = 'WGS84', ...rest } = params;
  return get<RegionByCoordRes>('/api/map/region/by-coord', { ...rest, inputCoord, outputCoord });
}

// 5) /api/map/address/by-coord
type AddressItem = {
  address_name: string;
  address_type: string;
  x: string;
  y: string;
  address?: {
    address_name: string;
    region_1depth_name: string;
    region_2depth_name: string;
    region_3depth_name: string;
    region_3depth_h_name: string;
    h_code: string;
    b_code: string;
    mountain_yn: string;
    main_address_no: string;
    sub_address_no: string;
    x: string;
    y: string;
  };
  road_address?: {
    address_name: string;
    region_1depth_name: string;
    region_2depth_name: string;
    region_3depth_name: string;
    road_name: string;
    underground_yn: string;
    main_building_no: string;
    sub_building_no: string;
    building_name: string;
    zone_no: string;
    x: string;
    y: string;
  };
};
type AddressByCoordRes = { meta: Meta; documents: { address?: AddressItem['address']; road_address?: AddressItem['road_address'] }[] };
async function apiAddressByCoord(params: { x: number; y: number; inputCoord?: 'WGS84' | string }) {
  const { inputCoord = 'WGS84', ...rest } = params;
  return get<AddressByCoordRes>('/api/map/address/by-coord', { ...rest, inputCoord });
}

/* ==== Î≥¥Ìñâ Í≤ΩÎ°ú API ======================================================= */
export type WalkRouteRes = {
  distanceMeters: number;
  durationSeconds: number;
  encodedPolyline: string;
  humanDailyCaloriesKcal?: number;
  humanWalkCaloriesKcal?: number;
  dogs?: Array<{
    dogId?: number;
    name: string;
    ageMonths?: number;
    weightKg?: number;
    dogDailyCaloriesKcal?: number;
    dogWalkCaloriesKcal?: number;
  }>;
};
async function apiRouteWalk(body: {
  origin: { latitude: number; longitude: number };
  destination: { latitude: number; longitude: number };
  dogNames?: string[];
}) {
  return post<WalkRouteRes>('/api/route/walk', body);
}

/* ==== (ÏÑ†ÌÉù) Í∞ïÏïÑÏßÄ ÏÑúÎ≤Ñ Îì±Î°ù API ======================================== */
async function apiRegisterDogs(body: {
  dogs: Array<{ name: string; breed: string; weightKg: number; ageMonths: number }>;
}) {
  try { await post('/api/dogs/profile', body); } catch {}
}

/* ==== Í≥µÌÜµ: Íµ¨Í∏Ä Encoded Polyline ÎîîÏΩîÎçî ================================ */
function decodePolyline(encoded: string): { latitude: number; longitude: number }[] {
  let index = 0, lat = 0, lng = 0;
  const coordinates: { latitude: number; longitude: number }[] = [];
  while (index < encoded.length) {
    let b, shift = 0, result = 0;
    do { b = encoded.charCodeAt(index++) - 63; result |= (b & 0x1f) << shift; shift += 5; } while (b >= 0x20);
    const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
    lat += dlat;
    shift = 0; result = 0;
    do { b = encoded.charCodeAt(index++) - 63; result |= (b & 0x1f) << shift; shift += 5; } while (b >= 0x20);
    const dlng = (result & 1) ? ~(result >> 1) : (result >> 1);
    lng += dlng;
    coordinates.push({ latitude: lat / 1e5, longitude: lng / 1e5 });
  }
  return coordinates;
}

/* =========================================================================
   ÌôîÎ©¥ ÏΩîÎìú
   ========================================================================= */

interface RunningRecord {
  duration: string;
  distance: string;
  calories: string;
  dogCalories: string;
}
interface DayEntry { runningRecord?: RunningRecord; }
interface DayRecord {
  date: string;
  photos: string[];
  memo: string;
  mood: 'üòä' | 'üòê' | 'üò¢' | 'ü§ó' | 'üò¥' | '';
  entries?: DayEntry[];
  runningRecord?: RunningRecord;
  runningLogs?: RunningRecord[];
}
interface LocationCoords { latitude: number; longitude: number; }
interface DogInfo {
  name: string; weight: number; age: number; breed: string;
  activityLevel: 'low' | 'medium' | 'high';
  avatarUri?: string;
}

/* ===== ÏïÑÎ∞îÌÉÄ(ÏÇ¨ÏßÑ ÏóÜÏúºÎ©¥ Ïù¥ÎãàÏÖú Î∞∞ÏßÄ) ================================== */
const initials = (name = '?') => name.trim().slice(0, 2).toUpperCase();
const colorFromString = (s: string) => {
  let h = 0; for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) % 360;
  return `hsl(${h},70%,55%)`;
};
const Avatar = ({ dog, size = 40 }: { dog?: Partial<DogInfo>, size?: number }) => {
  const uri = dog?.avatarUri;
  if (uri) return <Image source={{ uri }} style={{ width: size, height: size, borderRadius: size / 2 }} />;
  return (
    <View style={{
      width: size, height: size, borderRadius: size / 2,
      backgroundColor: colorFromString(dog?.name || '?'),
      alignItems: 'center', justifyContent: 'center'
    }}>
      <Text style={{ color: '#fff', fontWeight: '800' }}>{initials(dog?.name || '?')}</Text>
    </View>
  );
};

export default function RunningScreen() {
  const insets = useSafeAreaInsets();

  const [isRunning, setIsRunning] = useState(false);
  const [activityType, setActivityType] = useState<'run' | 'walk'>('run');
  const [showActivityPicker, setShowActivityPicker] = useState(false);

  const [time, setTime] = useState('00:00');
  const [seconds, setSeconds] = useState(0);
  const [location, setLocation] = useState<LocationCoords | null>(null);
  const [route, setRoute] = useState<LocationCoords[]>([]);
  const [distance, setDistance] = useState(0);
  const [isLoading, setIsLoading] = useState(true);

  // Î™©Ï†ÅÏßÄ(ÏßÄÎèÑÎ•º Í∏∏Í≤å ÎàåÎü¨ ÏÑ†ÌÉù)
  const [destination, setDestination] = useState<LocationCoords | null>(null);

  const [dogProfiles, setDogProfiles] = useState<DogInfo[]>([]);
  const [activeDogIndex, setActiveDogIndex] = useState<number | null>(null);
  const [selectedDogIndices, setSelectedDogIndices] = useState<number[]>([]);

  const [humanCalories, setHumanCalories] = useState(0);
  const [dogCaloriesTotal, setDogCaloriesTotal] = useState(0);
  const [isCompleted, setIsCompleted] = useState(false);

  const [showDogManageModal, setShowDogManageModal] = useState(false);
  const [showDogPicker, setShowDogPicker] = useState(false);

  const [formMode, setFormMode] = useState<'create' | 'edit'>('create');
  const [dogForm, setDogForm] = useState({
    name: '', weight: '', age: '',
    breed: 'ÎØπÏä§Í≤¨',
    activityLevel: 'medium' as 'low' | 'medium' | 'high',
    avatarUri: '',
  });

  // ‚úÖ ÌòÑÏû¨ ÏúÑÏπò Ï£ºÏÜå ÌëúÍ∏∞Ïö©
  const [addressLine, setAddressLine] = useState<string>('');

  // Í≤ΩÎ°ú(ÏÑúÎ≤Ñ Î∞òÌôò)
  const [walkPath, setWalkPath] = useState<LocationCoords[]>([]);

  // ÏãúÏä§ÌÖú UI
  useEffect(() => {
    const hideNavigationBar = async () => {
      if (Platform.OS === 'android') {
        try {
          const NavigationBar = await import('expo-navigation-bar');
          await NavigationBar.setVisibilityAsync('hidden');
          await NavigationBar.setBehaviorAsync('overlay-swipe');
        } catch {}
      }
    };
    hideNavigationBar();
  }, []);

  // ÏúÑÏπò Ï¥àÍ∏∞Ìôî (+ Ï£ºÏÜå/ÌñâÏ†ïÎèô Ï°∞Ìöå)
  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        const { status, canAskAgain } = await Location.requestForegroundPermissionsAsync();
        if (status !== 'granted') {
          if (canAskAgain) Alert.alert('Í∂åÌïú ÌïÑÏöî', 'ÏúÑÏπò Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ïïº ÏßÄÎèÑÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.');
          else Alert.alert('Í∂åÌïú ÌïÑÏöî', 'ÏÑ§Ï†ïÏóêÏÑú ÏúÑÏπò Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.');
          if (!cancelled) setIsLoading(false);
          return;
        }
        const current = await Promise.race([
          Location.getCurrentPositionAsync({ accuracy: Location.Accuracy.Balanced, mayShowUserSettingsDialog: true }),
          new Promise<null>((resolve) => setTimeout(() => resolve(null), 8000))
        ]);
        let coords: LocationCoords | null = null;
        if (current && 'coords' in current) {
          coords = { latitude: current.coords.latitude, longitude: current.coords.longitude };
        } else {
          const last = await Location.getLastKnownPositionAsync();
          if (last) coords = { latitude: last.coords.latitude, longitude: last.coords.longitude };
        }
        if (!coords) {
          coords = { latitude: 37.5665, longitude: 126.9780 };
          Alert.alert('ÏïàÎÇ¥', 'ÌòÑÏû¨ ÏúÑÏπòÎ•º Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌï¥ Í∏∞Î≥∏ ÏúÑÏπòÎ°ú ÌëúÏãúÌï©ÎãàÎã§.');
        }
        if (!cancelled) {
          setLocation(coords);
          setRoute([coords]);
          setIsLoading(false);

          try {
            const [region, addr] = await Promise.all([
              apiRegionByCoord({ x: coords.longitude, y: coords.latitude }),
              apiAddressByCoord({ x: coords.longitude, y: coords.latitude })
            ]);
            const dong = region.documents?.[0]?.address_name ?? '';
            const road = addr.documents?.[0]?.road_address?.address_name;
            const jibun = addr.documents?.[0]?.address?.address_name;
            setAddressLine(road || jibun || dong || '');
          } catch {}
        }
      } catch {
        if (!cancelled) {
          const fallback = { latitude: 37.5665, longitude: 126.9780 };
          setLocation(fallback);
          setRoute([fallback]);
          setIsLoading(false);
        }
      }
    })();
    return () => { cancelled = true; };
  }, []);

  // ÌÉÄÏù¥Î®∏
  useEffect(() => {
    let interval: ReturnType<typeof setInterval> | undefined;
    if (isRunning) {
      interval = setInterval(() => {
        setSeconds((prev) => {
          const next = prev + 1;
          const m = Math.floor(next / 60);
          const s = next % 60;
          setTime(`${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`);
          return next;
        });
      }, 1000);
    }
    return () => { if (interval) clearInterval(interval); };
  }, [isRunning]);

  // Ïù¥Îèô Í≤ΩÎ°ú Ï∂îÏ†Å
  useEffect(() => {
    let sub: Location.LocationSubscription | undefined;
    const track = async () => {
      if (isRunning) {
        sub = await Location.watchPositionAsync(
          { accuracy: Location.Accuracy.Balanced, timeInterval: 3000, distanceInterval: 5 },
          (loc) => {
            const p = { latitude: loc.coords.latitude, longitude: loc.coords.longitude };
            setLocation(p);
            setRoute((prev) => {
              const next = [...prev, p];
              calculateDistance(next);
              return next;
            });
          }
        );
      }
    };
    track();
    return () => { if (sub) sub.remove(); };
  }, [isRunning]);

  // Í∞ïÏïÑÏßÄ Î™©Î°ù Î°úÎìú
  useEffect(() => {
    (async () => {
      const raw = await AsyncStorage.getItem('dogProfiles');
      if (raw) {
        const arr: DogInfo[] = JSON.parse(raw);
        setDogProfiles(arr);
        setActiveDogIndex(arr.length ? 0 : null);
      }
    })();
  }, []);

  // ÏπºÎ°úÎ¶¨ Í≥ÑÏÇ∞ Ìä∏Î¶¨Í±∞
  useEffect(() => {
    if (distance > 0 && seconds > 0) calculateCalories();
  }, [distance, seconds, activityType, selectedDogIndices.join(','), dogProfiles.length]);

  // ÏôÑÎ£å Î∞∞ÎÑà ÏûêÎèô Ïà®ÍπÄ
  useEffect(() => {
    if (!isCompleted) return;
    const t = setTimeout(() => setIsCompleted(false), 5000);
    return () => clearTimeout(t);
  }, [isCompleted]);

  const calculateDistance = (coordinates: LocationCoords[]) => {
    if (coordinates.length < 2) return;
    let total = 0;
    for (let i = 1; i < coordinates.length; i++) {
      total += getDistanceBetweenPoints(coordinates[i - 1], coordinates[i]);
    }
    setDistance(total);
  };

  const getDistanceBetweenPoints = (a: LocationCoords, b: LocationCoords) => {
    const R = 6371;
    const dLat = (b.latitude - a.latitude) * Math.PI / 180;
    const dLon = (b.longitude - a.longitude) * Math.PI / 180;
    const s =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(a.latitude * Math.PI / 180) * Math.cos(b.latitude * Math.PI / 180) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s));
    return R * c; // km
  };

  const calculateCalories = () => {
    const h = seconds / 3600;
    const humanPerHour = activityType === 'run' ? 700 : 280;
    setHumanCalories(Math.round(humanPerHour * h));

    const typeFactor = activityType === 'run' ? 1.0 : 0.7;
    const totalDog = selectedDogIndices.reduce((sum, idx) => {
      const d = dogProfiles[idx];
      if (!d) return sum;
      return sum + calculateDogCalories(d, h, distance, typeFactor);
    }, 0);
    setDogCaloriesTotal(totalDog);
  };

  const saveToCalendar = async (runningData: RunningRecord) => {
    try {
      const today = new Date().toISOString().split('T')[0];
      const existing = await AsyncStorage.getItem('dayRecords');
      let records: DayRecord[] = existing ? JSON.parse(existing) : [];
      const idx = records.findIndex((r) => r.date === today);

      if (idx >= 0) {
        const rec = records[idx];
        let entries: DayEntry[] = Array.isArray(rec.entries) ? rec.entries.slice() : [];
        if (rec.runningLogs?.length) {
          entries = [...entries, ...rec.runningLogs.map(l => ({ runningRecord: l }))];
        }
        if (rec.runningRecord) entries.push({ runningRecord: rec.runningRecord });
        entries.push({ runningRecord: runningData });
        records[idx] = { ...rec, entries, runningLogs: undefined, runningRecord: undefined };
      } else {
        records.push({ date: today, photos: [], memo: '', mood: '', entries: [{ runningRecord: runningData }] });
      }
      await AsyncStorage.setItem('dayRecords', JSON.stringify(records));
      return true;
    } catch {
      return false;
    }
  };

  const calculateDogCalories = (dog: DogInfo, hours: number, km: number, typeFactor = 1.0) => {
    const base = 70 * Math.pow(dog.weight, 0.75);
    const act = { low: 1.2, medium: 1.4, high: 1.8 }[dog.activityLevel];
    const breed: { [k: string]: number } = {
      'Í≥®Îì† Î¶¨Ìä∏Î¶¨Î≤Ñ': 1.3, 'ÎûòÎ∏åÎùºÎèÑ': 1.3, 'ÌóàÏä§ÌÇ§': 1.5, 'Î≥¥Îçî ÏΩúÎ¶¨': 1.4, 'ÎπÑÍ∏Ä': 1.2,
      'ÏãúÎ∞îÍ≤¨': 1.1, 'ÏßÑÎèóÍ∞ú': 1.2, 'ÎßêÌã∞Ï¶à': 0.9, 'ÎπÑÏàë ÌîÑÎ¶¨Ï†ú': 1.0, 'ÏπòÏôÄÏôÄ': 0.8,
      'ÏöîÌÅ¨ÏÖîÌÖåÎ¶¨Ïñ¥': 0.8, 'Ìë∏Îì§': 1.0, 'Î∂àÎèÖ': 0.9, 'ÎØπÏä§Í≤¨': 1.0
    };
    const speed = km > 0 && hours > 0 ? Math.min(km / hours, 15) : 5;
    const intensity = (1 + speed / 20) * typeFactor;
    const daily = base * act * (breed[dog.breed] || 1.0);
    const perHour = daily / 24;
    return Math.round(perHour * intensity * hours);
  };

  const openStartFlow = () => {
    if (isRunning) {
      setIsRunning(false);
      setIsCompleted(true);
      if (seconds > 0 && (distance > 0 || humanCalories > 0)) {
        const names = selectedDogIndices.map(i => dogProfiles[i]?.name).filter(Boolean).join(', ');
        Alert.alert(
          'üèÉ‚Äç‚ôÇÔ∏è Ïö¥Îèô ÏôÑÎ£å!',
          `ÏãúÍ∞Ñ: ${time}\nÍ±∞Î¶¨: ${distance.toFixed(2)}km\nÎÇ¥ ÏπºÎ°úÎ¶¨: ${humanCalories}kcal\nÍ∞ïÏïÑÏßÄ ÏπºÎ°úÎ¶¨(Ìï©Í≥Ñ): ${dogCaloriesTotal}kcal${names ? `\nÎèôÎ∞ò: ${names}` : ''}\n\nÏ∫òÎ¶∞ÎçîÏóê Í∏∞Î°ùÌïòÏãúÍ≤†ÏäµÎãàÍπå?`,
          [
            { text: 'ÏïÑÎãàÏò§', style: 'cancel' },
            {
              text: 'Ïòà',
              onPress: async () => {
                const data: RunningRecord = {
                  duration: time, distance: `${distance.toFixed(2)}km`,
                  calories: `${humanCalories}`, dogCalories: `${dogCaloriesTotal}`
                };
                const ok = await saveToCalendar(data);
                if (ok) Alert.alert('Ï†ÄÏû• ÏôÑÎ£å!', 'Ïò§ÎäòÏùò Ïö¥Îèô Í∏∞Î°ùÏù¥ Ï∫òÎ¶∞ÎçîÏóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§! üìÖ');
                else Alert.alert('Ï†ÄÏû• Ïã§Ìå®', 'Ï∫òÎ¶∞Îçî Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
              }
            }
          ]
        );
      }
    } else {
      setShowActivityPicker(true);
    }
  };

  const startWithType = (t: 'run' | 'walk') => {
    setActivityType(t);
    setShowActivityPicker(false);
    setIsRunning(true);
    setSeconds(0);
    setTime('00:00');
    setDistance(0);
    setHumanCalories(0);
    setDogCaloriesTotal(0);
    setIsCompleted(false);
    setWalkPath([]);
    if (location) setRoute([location]);
  };

  const handleReset = () => {
    Alert.alert('Ï¥àÍ∏∞Ìôî ÌôïÏù∏', 'ÌòÑÏû¨ Ïö¥Îèô Í∏∞Î°ùÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?', [
      { text: 'Ï∑®ÏÜå', style: 'cancel' },
      {
        text: 'Ï¥àÍ∏∞Ìôî',
        onPress: () => {
          setIsRunning(false);
          setSeconds(0);
          setTime('00:00');
          setDistance(0);
          setHumanCalories(0);
          setDogCaloriesTotal(0);
          setIsCompleted(false);
          setWalkPath([]);
          setDestination(null);
          if (location) setRoute([location]);
        }
      }
    ]);
  };

  // ‚úÖ Î≥¥Ìñâ Í≤ΩÎ°ú Ìò∏Ï∂ú(ÌòÑÏû¨ ÏúÑÏπò ‚Üí ÏÇ¨Ïö©ÏûêÍ∞Ä Ï∞çÏùÄ Î™©Ï†ÅÏßÄ)
  const requestWalkRoute = async () => {
    if (!location) return;
    if (!destination) {
      Alert.alert('Î™©Ï†ÅÏßÄ ÏóÜÏùå', 'ÏßÄÎèÑÎ•º Í∏∏Í≤å ÎàåÎü¨ Î™©Ï†ÅÏßÄÎ•º Î®ºÏ†Ä ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.');
      return;
    }
    try {
      const dogNames = selectedDogIndices.map(i => dogProfiles[i]?.name).filter(Boolean) as string[];
      const res = await apiRouteWalk({
        origin: { latitude: location.latitude, longitude: location.longitude },
        destination: { latitude: destination.latitude, longitude: destination.longitude },
        dogNames,
      });

      const decoded = decodePolyline(res.encodedPolyline);
      setWalkPath(decoded);

      if (typeof res.humanWalkCaloriesKcal === 'number') setHumanCalories(res.humanWalkCaloriesKcal);
      if (Array.isArray(res.dogs)) {
        const sum = res.dogs.reduce((acc, d) => acc + (d.dogWalkCaloriesKcal ?? 0), 0);
        if (sum > 0) setDogCaloriesTotal(sum);
      }

      if (typeof res.distanceMeters === 'number') setDistance(res.distanceMeters / 1000);
      if (typeof res.durationSeconds === 'number') {
        setSeconds(res.durationSeconds);
        const m = Math.floor(res.durationSeconds / 60);
        const s = res.durationSeconds % 60;
        setTime(`${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`);
      }
    } catch (e: any) {
      const msg = String(e?.message ?? '');
      if (msg.includes(' 401 ') || /401\b/.test(msg)) {
        Alert.alert(
          'Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§',
          'ÏÑ∏ÏÖòÏù¥ ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò Î°úÍ∑∏Ïù∏ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥ Ï£ºÏÑ∏Ïöî.',
          [
            { text: 'Ï∑®ÏÜå', style: 'cancel' },
            { text: 'Î°úÍ∑∏Ïù∏ÏúºÎ°ú Ïù¥Îèô', onPress: () => router.replace('/sign') },
          ]
        );
      } else {
        Alert.alert('Ïò§Î•ò', msg || 'route/walk Ìò∏Ï∂ú Ïã§Ìå®');
      }
    }
  };

  const newDogForm = () => {
    setFormMode('create');
    setDogForm({ name: '', weight: '', age: '', breed: 'ÎØπÏä§Í≤¨', activityLevel: 'medium', avatarUri: '' });
    setShowDogManageModal(true);
  };
  const editSelectedDog = (index: number) => {
    setActiveDogIndex(index);
    const d = dogProfiles[index];
    setFormMode('edit');
    setDogForm({
      name: d.name,
      weight: String(d.weight),
      age: String(d.age),
      breed: d.breed,
      activityLevel: d.activityLevel,
      avatarUri: d.avatarUri || ''
    });
    setShowDogManageModal(true);
  };

  // ‚úÖ Í∞§Îü¨Î¶¨ÏóêÏÑú ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏÑ†ÌÉù/Ï†úÍ±∞
  const pickAvatar = async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('Í∂åÌïú ÌïÑÏöî', 'ÏÇ¨ÏßÑ Î≥¥Í¥ÄÌï® Ï†ëÍ∑ºÏùÑ ÌóàÏö©Ìï¥Ïïº ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑÏùÑ ÏÑ†ÌÉùÌï† Ïàò ÏûàÏäµÎãàÎã§.');
      return;
    }
    const res = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 0.9,
    });
    if (!res.canceled && res.assets?.[0]?.uri) {
      setDogForm((p) => ({ ...p, avatarUri: res.assets[0].uri }));
    }
  };
  const removeAvatar = () => setDogForm((p) => ({ ...p, avatarUri: '' }));

  const saveDogInfo = async () => {
    if (!dogForm.name || !dogForm.weight || !dogForm.age) {
      Alert.alert('ÏûÖÎ†• Ïò§Î•ò', 'Î™®Îì† Ï†ïÎ≥¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }
    const info: DogInfo = {
      name: dogForm.name,
      weight: parseFloat(dogForm.weight),
      age: parseInt(dogForm.age),
      breed: dogForm.breed,
      activityLevel: dogForm.activityLevel,
      avatarUri: dogForm.avatarUri || undefined
    };

    const nextProfiles = [...dogProfiles];
    if (formMode === 'create') {
      nextProfiles.push(info);
      setActiveDogIndex(nextProfiles.length - 1);
      apiRegisterDogs({
        dogs: [{ name: info.name, breed: info.breed, weightKg: info.weight, ageMonths: info.age * 12 }]
      }).catch(() => {});
    } else if (formMode === 'edit' && activeDogIndex !== null) {
      nextProfiles[activeDogIndex] = info;
    }

    setDogProfiles(nextProfiles);
    await AsyncStorage.setItem('dogProfiles', JSON.stringify(nextProfiles));
    setShowDogManageModal(false);
    Alert.alert('Ï†ÄÏû• ÏôÑÎ£å', `${info.name}Ïùò Ï†ïÎ≥¥Í∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!`);
  };

  const deleteDog = async () => {
    if (activeDogIndex === null) return;
    const target = dogProfiles[activeDogIndex];
    Alert.alert('ÏÇ≠Ï†ú ÌôïÏù∏', `${target.name} ÌîÑÎ°úÌïÑÏùÑ ÏÇ≠Ï†úÌï†ÍπåÏöî?`, [
      { text: 'Ï∑®ÏÜå', style: 'cancel' },
      {
        text: 'ÏÇ≠Ï†ú',
        style: 'destructive',
        onPress: async () => {
          const removedIndex = activeDogIndex;
          const next = dogProfiles.filter((_, i) => i !== removedIndex);
          const nextSelected = selectedDogIndices
            .filter(i => i !== removedIndex)
            .map(i => (i > removedIndex ? i - 1 : i));

          setDogProfiles(next);
          setSelectedDogIndices(nextSelected);
          await AsyncStorage.setItem('dogProfiles', JSON.stringify(next));

          if (next.length === 0) {
            setActiveDogIndex(null);
            setFormMode('create');
            setDogForm({ name: '', weight: '', age: '', breed: 'ÎØπÏä§Í≤¨', activityLevel: 'medium', avatarUri: '' });
          } else {
            const nextIndex = Math.min(removedIndex, next.length - 1);
            setActiveDogIndex(nextIndex);
            setFormMode('edit');
            const d = next[nextIndex];
            setDogForm({
              name: d.name, weight: String(d.weight), age: String(d.age),
              breed: d.breed, activityLevel: d.activityLevel, avatarUri: d.avatarUri || ''
            });
          }
          Alert.alert('ÏÇ≠Ï†ú ÏôÑÎ£å', 'ÌîÑÎ°úÌïÑÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.');
        }
      }
    ]);
  };

  const toggleSelectDog = (idx: number) => {
    setSelectedDogIndices(prev => (
      prev.includes(idx) ? prev.filter(i => i !== idx) : [...prev, idx]
    ));
  };
  const clearSelection = () => setSelectedDogIndices([]);

  // ÏßÄÎèÑ Í∏∏Í≤å ÎàåÎü¨ Î™©Ï†ÅÏßÄ ÏÑ†ÌÉù
  const onLongPressMap = (e: MapEvent) => {
    const { latitude, longitude } = e.nativeEvent.coordinate;
    setDestination({ latitude, longitude });
    setWalkPath([]);
  };

  if (isLoading) {
    return (
      <SafeAreaView style={[styles.container, { paddingTop: insets.top }]}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#FF6B6B" />
        </View>
      </SafeAreaView>
    );
  }

  return (
    <>
      <StatusBar barStyle="dark-content" backgroundColor="#AEC3A9" />
      <SafeAreaView style={[styles.container, { paddingTop: insets.top }]}>
        {/* Ï£ºÏÜå Î∞∞ÏßÄ */}
        {addressLine ? (
          <View style={styles.addressBadge}>
            <Text style={styles.addressBadgeText} numberOfLines={1}>{addressLine}</Text>
          </View>
        ) : null}

        {/* ‚ñº Î∞îÎã• Ïñ∏ÎçîÎ†àÏù¥ */}
        <View pointerEvents="none" style={[styles.bottomUnderlay, { height: (insets.bottom ?? 0) + 120 }]} />

        {/* ÏßÄÎèÑ */}
        <View style={[styles.mapContainer, { flex: 1.5, marginTop: -12, marginBottom: -5 }]}>
          {location && (
            <MapView
              provider={PROVIDER_GOOGLE}
              style={styles.map}
              initialRegion={{
                latitude: location.latitude,
                longitude: location.longitude,
                latitudeDelta: 0.01,
                longitudeDelta: 0.01
              }}
              showsUserLocation
              followsUserLocation={isRunning}
              showsMyLocationButton
              onLongPress={onLongPressMap}
            >
              <Marker coordinate={location} title="ÌòÑÏû¨ ÏúÑÏπò" pinColor="#FF6B6B" />
              {destination && <Marker coordinate={destination} title="Î™©Ï†ÅÏßÄ" pinColor="#2D9CDB" />}
              {route.length > 1 && (
                <Polyline coordinates={route} strokeColor="#FF6B6B" strokeWidth={4} lineCap="round" lineJoin="round" />
              )}
              {walkPath.length > 1 && (
                <Polyline coordinates={walkPath} strokeColor="#4ECDC4" strokeWidth={4} lineCap="round" lineJoin="round" />
              )}
            </MapView>
          )}
        </View>

        {/* ‚úÖ ÌûåÌä∏: Ï°∞Í∏à ÏïÑÎûò + Î∞ùÏùÄ ÌöåÏÉâ */}
        {!destination && (
          <View style={styles.destHintWrap}>
            <Text style={styles.destHintText}>ÏßÄÎèÑÎ•º Í∏∏Í≤å ÎàåÎü¨ Î™©Ï†ÅÏßÄÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</Text>
          </View>
        )}

        {/* ÏÑ†ÌÉùÎêú Í∞ïÏïÑÏßÄ Î∞∞ÎÑà */}
        {selectedDogIndices.length > 0 && (
          <View style={styles.dogInfoBanner}>
            <Text style={styles.dogInfoText}>
              üêï ÎèôÎ∞ò: {selectedDogIndices.map(i => dogProfiles[i]?.name).filter(Boolean).join(', ')}
            </Text>
          </View>
        )}

        {/* ÌïòÎã® Ìå®ÎÑê */}
        <View style={[styles.runningInfo, { paddingBottom: 80 + insets.bottom }]}>
          {/* ÏÉÅÎã® Ìñâ */}
          <View style={styles.panelTopRow}>
            {/* Ï¢åÏ∏°: ÎèôÎ∞ò Í∞ïÏïÑÏßÄ */}
            <TouchableOpacity style={styles.miniSelectDogBtn} onPress={() => setShowDogPicker(true)}>
              <Text style={styles.miniSelectDogTxt}>ÎèôÎ∞ò Í∞ïÏïÑÏßÄ</Text>
              {selectedDogIndices.length > 0 && (
                <View style={styles.miniBadge}>
                  <Text style={styles.miniBadgeTxt}>{selectedDogIndices.length}</Text>
                </View>
              )}
            </TouchableOpacity>

            {/* Í∞ÄÏö¥Îç∞: ÏÇ∞Ï±Ö Í≤ΩÎ°úÎßå */}
            <View style={styles.topRowActions}>
              <TouchableOpacity style={styles.manageBtn} onPress={requestWalkRoute}>
                <Text style={styles.manageBtnText}>ÏÇ∞Ï±Ö Í≤ΩÎ°ú</Text>
              </TouchableOpacity>
            </View>

            {/* Ïö∞Ï∏°: ÌîÑÎ°úÌïÑ Í¥ÄÎ¶¨ */}
            <TouchableOpacity style={styles.manageBtn} onPress={newDogForm}>
              <Text style={styles.manageBtnText}>ÌîÑÎ°úÌïÑ Í¥ÄÎ¶¨</Text>
            </TouchableOpacity>
          </View>

          <View style={styles.timerContainer}>
            <Text style={styles.timerText}>{time}</Text>
            <Text style={styles.timerLabel}>Í≤ΩÍ≥º ÏãúÍ∞Ñ ¬∑ {activityType === 'run' ? 'Îü∞Îãù' : 'ÏÇ∞Ï±Ö'}</Text>
          </View>

          {/* Ïª®Ìä∏Î°§ */}
          <View style={[styles.controlButtons, { marginBottom: 6 }]}>
            <TouchableOpacity
              style={[styles.runButton, { backgroundColor: isRunning ? '#E74C3C' : '#27AE60' }]}
              onPress={openStartFlow}
            >
              <Text style={styles.runButtonText}>{isRunning ? 'Ï†ïÏßÄ' : 'ÏãúÏûë'}</Text>
            </TouchableOpacity>

            <TouchableOpacity style={styles.resetButton} onPress={handleReset}>
              <Text style={styles.resetButtonText}>Ï¥àÍ∏∞Ìôî</Text>
            </TouchableOpacity>
          </View>

          {/* ÏÑ†ÌÉù Ïπ© */}
          {selectedDogIndices.length > 0 && (
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={{ paddingHorizontal: 6 }}
              style={{ marginTop: 6 }}
            >
              <View style={styles.selectedChipRow}>
                {selectedDogIndices.map((idx) => {
                  const d = dogProfiles[idx];
                  if (!d) return null;
                  return (
                    <View key={`${d.name}-${idx}`} style={styles.selectedChip}>
                      <View style={{ marginRight: 6 }}>
                        <Avatar dog={d} size={18} />
                      </View>
                      <Text style={styles.selectedChipText}>{d.name}</Text>
                    </View>
                  );
                })}
              </View>
            </ScrollView>
          )}

          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{distance.toFixed(2)}</Text>
              <Text style={styles.statLabel}>km</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{humanCalories}</Text>
              <Text style={styles.statLabel}>ÎÇ¥ ÏπºÎ°úÎ¶¨</Text>
            </View>
            <View style={styles.statItem}>
              <Text style={styles.statValue}>{dogCaloriesTotal}</Text>
              <Text style={styles.statLabel}>üêï ÏπºÎ°úÎ¶¨(Ìï©Í≥Ñ)</Text>
            </View>
          </View>

          {isCompleted && (
            <View style={styles.completedBanner}>
              <Text style={styles.completedText}>üéâ Ïö¥Îèô ÏôÑÎ£å!</Text>
              <Text style={styles.completedSubtext}>Ï∫òÎ¶∞ÎçîÏóêÏÑú Í∏∞Î°ùÏùÑ ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî</Text>
            </View>
          )}
        </View>

        {/* ÎèôÎ∞ò Í∞ïÏïÑÏßÄ ÏÑ†ÌÉù Î™®Îã¨ */}
        <Modal visible={showDogPicker} animationType="slide" transparent onRequestClose={() => setShowDogPicker(false)}>
          <View style={styles.modalOverlay}>
            <View style={styles.modalContent}>
              <Text style={styles.modalTitle}>üê∂ ÎèôÎ∞ò Í∞ïÏïÑÏßÄ ÏÑ†ÌÉù</Text>
              <ScrollView style={{ maxHeight: 400 }}>
                {dogProfiles.length === 0 ? (
                  <Text style={{ color: '#2C3E50', marginBottom: 12 }}>
                    Îì±Î°ùÎêú Í∞ïÏïÑÏßÄÍ∞Ä ÏóÜÏñ¥Ïöî. ÏïÑÎûò 'ÌîÑÎ°úÌïÑ Ï∂îÍ∞Ä'Î°ú ÎßåÎì§Ïñ¥Ï£ºÏÑ∏Ïöî.
                  </Text>
                ) : (
                  dogProfiles.map((d, idx) => {
                    const selected = selectedDogIndices.includes(idx);
                    return (
                      <TouchableOpacity
                        key={`${d.name}-${idx}`}
                        style={[styles.pickRow, selected && styles.pickRowSelected]}
                        onPress={() => toggleSelectDog(idx)}
                      >
                        <View style={[styles.checkbox, selected && styles.checkboxChecked]}>
                          {selected && <Text style={styles.checkboxMark}>‚úì</Text>}
                        </View>

                        <View style={{ marginRight: 10 }}>
                          <Avatar dog={d} size={40} />
                        </View>

                        <View style={{ flex: 1 }}>
                          <Text style={styles.pickName}>{d.name} ({d.weight}kg, {d.breed})</Text>
                          <Text style={styles.pickSub}>ÌôúÎèôÏÑ±: {d.activityLevel === 'low' ? 'ÎÇÆÏùå' : d.activityLevel === 'medium' ? 'Î≥¥ÌÜµ' : 'ÎÜíÏùå'}</Text>
                        </View>
                        <TouchableOpacity style={styles.pickEdit} onPress={() => { setShowDogPicker(false); editSelectedDog(idx); }}>
                          <Text style={styles.pickEditText}>ÏàòÏ†ï</Text>
                        </TouchableOpacity>
                      </TouchableOpacity>
                    );
                  })
                )}
              </ScrollView>

              <View style={styles.modalButtons}>
                <TouchableOpacity style={styles.modalGhostButton} onPress={clearSelection}>
                  <Text style={styles.modalGhostText}>ÏÑ†ÌÉù Ìï¥Ï†ú</Text>
                </TouchableOpacity>
                <TouchableOpacity style={styles.modalGhostButton} onPress={newDogForm}>
                  <Text style={styles.modalGhostText}>ÌîÑÎ°úÌïÑ Ï∂îÍ∞Ä</Text>
                </TouchableOpacity>
                <TouchableOpacity style={styles.modalSaveButton} onPress={() => setShowDogPicker(false)}>
                  <Text style={styles.modalSaveText}>ÏôÑÎ£å</Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </Modal>

        {/* ÌôúÎèô ÏÑ†ÌÉù Î™®Îã¨ */}
        <Modal visible={showActivityPicker} transparent animationType="fade" onRequestClose={() => setShowActivityPicker(false)}>
          <View style={styles.modalOverlay}>
            <View style={[styles.modalContent, { paddingVertical: 24 }]}>
              <Text style={styles.modalTitle}>ÌôúÎèôÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</Text>
              <View style={{ flexDirection: 'row', gap: 10, marginTop: 6 }}>
                <TouchableOpacity style={styles.activityPickBtn} onPress={() => startWithType('run')}>
                  <Text style={styles.activityPickTxt}>üèÉ‚Äç‚ôÇÔ∏è Îü∞Îãù</Text>
                </TouchableOpacity>
                <TouchableOpacity style={[styles.activityPickBtn, { backgroundColor: '#4ECDC4' }]} onPress={() => startWithType('walk')}>
                  <Text style={styles.activityPickTxt}>üö∂ ÏÇ∞Ï±Ö</Text>
                </TouchableOpacity>
              </View>
              <TouchableOpacity onPress={() => setShowActivityPicker(false)} style={{ marginTop: 10, alignSelf: 'center' }}>
                <Text style={{ color: '#7F8C8D', fontWeight: '700' }}>Ï∑®ÏÜå</Text>
              </TouchableOpacity>
            </View>
          </View>
        </Modal>

        {/* Í∞ïÏïÑÏßÄ ÌîÑÎ°úÌïÑ Í¥ÄÎ¶¨ Î™®Îã¨ */}
        <Modal visible={showDogManageModal} animationType="slide" transparent onRequestClose={() => setShowDogManageModal(false)}>
          <View style={styles.modalOverlay}>
            <View style={styles.modalContent}>
              <Text style={styles.modalTitle}>üêï Í∞ïÏïÑÏßÄ Ï†ïÎ≥¥</Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false} style={{ marginBottom: 12 }}>
                <View style={styles.dogChipRow}>
                  {dogProfiles.map((d, idx) => (
                    <TouchableOpacity
                      key={`${d.name}-${idx}`}
                      style={[styles.dogChip, activeDogIndex === idx && styles.dogChipActive]}
                      onPress={() => editSelectedDog(idx)}
                    >
                      <Avatar dog={d} size={22} />
                      <Text style={[styles.dogChipText, activeDogIndex === idx && styles.dogChipTextActive, { marginLeft: 6 }]}>
                        {d.name}
                      </Text>
                    </TouchableOpacity>
                  ))}
                  <TouchableOpacity style={styles.dogChipAdd} onPress={newDogForm}>
                    <Text style={styles.dogChipAddText}>+ ÏÉà Í∞ïÏïÑÏßÄ</Text>
                  </TouchableOpacity>
                </View>
              </ScrollView>

              <ScrollView style={styles.modalForm}>
                {/* ‚úÖ ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏÑ†ÌÉù */}
                <View style={{ alignItems: 'center', marginBottom: 16 }}>
                  <TouchableOpacity onPress={pickAvatar} activeOpacity={0.8} style={{ alignItems: 'center' }}>
                    <Avatar dog={{ name: dogForm.name, avatarUri: dogForm.avatarUri }} size={84} />
                    <Text style={{ marginTop: 8, color: '#2C3E50', fontWeight: '700' }}>
                      {dogForm.avatarUri ? 'ÏÇ¨ÏßÑ Î≥ÄÍ≤Ω' : 'ÏÇ¨ÏßÑ ÏÑ†ÌÉù'}
                    </Text>
                  </TouchableOpacity>
                  {dogForm.avatarUri ? (
                    <TouchableOpacity onPress={removeAvatar} style={{ marginTop: 6 }}>
                      <Text style={{ color: '#8A8F98' }}>ÏÇ¨ÏßÑ Ï†úÍ±∞</Text>
                    </TouchableOpacity>
                  ) : null}
                </View>

                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>Ïù¥Î¶Ñ</Text>
                  <TextInput style={styles.textInput} value={dogForm.name} onChangeText={(text) => setDogForm({ ...dogForm, name: text })} placeholder="Í∞ïÏïÑÏßÄ Ïù¥Î¶Ñ" />
                </View>
                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>Ï≤¥Ï§ë (kg)</Text>
                  <TextInput style={styles.textInput} value={dogForm.weight} onChangeText={(text) => setDogForm({ ...dogForm, weight: text })} placeholder="Ï≤¥Ï§ëÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî" keyboardType="numeric" />
                </View>
                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>ÎÇòÏù¥ (ÎÖÑ)</Text>
                  <TextInput style={styles.textInput} value={dogForm.age} onChangeText={(text) => setDogForm({ ...dogForm, age: text })} placeholder="ÎÇòÏù¥Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî" keyboardType="numeric" />
                </View>
                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>Í≤¨Ï¢Ö</Text>
                  <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                    <View style={styles.breedContainer}>
                      {[
                        'ÎØπÏä§Í≤¨','Í≥®Îì† Î¶¨Ìä∏Î¶¨Î≤Ñ','ÎûòÎ∏åÎùºÎèÑ','ÏãúÎ∞îÍ≤¨','Î≥¥Îçî ÏΩúÎ¶¨','ÌóàÏä§ÌÇ§',
                        'ÎßêÌã∞Ï¶à','Ìë∏Îì§','ÎπÑÏàë ÌîÑÎ¶¨Ï†ú','ÏπòÏôÄÏôÄ','ÏöîÌÅ¨ÏÖîÌÖåÎ¶¨Ïñ¥','ÎπÑÍ∏Ä','Î∂àÎèÖ','ÏßÑÎèóÍ∞ú'
                      ].map((breed) => (
                        <TouchableOpacity
                          key={breed}
                          style={[styles.breedButton, dogForm.breed === breed && styles.breedButtonSelected]}
                          onPress={() => setDogForm({ ...dogForm, breed })}
                        >
                          <Text style={[styles.breedButtonText, dogForm.breed === breed && styles.breedButtonTextSelected]}>
                            {breed}
                          </Text>
                        </TouchableOpacity>
                      ))}
                    </View>
                  </ScrollView>
                </View>
                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>ÌôúÎèôÏÑ±</Text>
                  <View style={styles.activityContainer}>
                    {(['low', 'medium', 'high'] as const).map((level) => (
                      <TouchableOpacity
                        key={level}
                        style={[styles.activityButton, dogForm.activityLevel === level && styles.activityButtonSelected]}
                        onPress={() => setDogForm({ ...dogForm, activityLevel: level })}
                      >
                        <Text style={[styles.activityButtonText, dogForm.activityLevel === level && styles.activityButtonTextSelected]}>
                          {level === 'low' ? 'ÎÇÆÏùå' : level === 'medium' ? 'Î≥¥ÌÜµ' : 'ÎÜíÏùå'}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                </View>
              </ScrollView>

              <View style={styles.modalButtons}>
                {formMode === 'edit' && activeDogIndex !== null && (
                  <TouchableOpacity style={styles.modalDeleteButton} onPress={deleteDog}>
                    <Text style={styles.modalDeleteText}>ÏÇ≠Ï†ú</Text>
                  </TouchableOpacity>
                )}
                <TouchableOpacity style={styles.modalCancelButton} onPress={() => setShowDogManageModal(false)}>
                  <Text style={styles.modalCancelText}>Îã´Í∏∞</Text>
                </TouchableOpacity>
                <TouchableOpacity style={styles.modalSaveButton} onPress={saveDogInfo}>
                  <Text style={styles.modalSaveText}>{formMode === 'create' ? 'Ï∂îÍ∞Ä' : 'ÏàòÏ†ï Ï†ÄÏû•'}</Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </Modal>
      </SafeAreaView>
    </>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#AEC3A9', position: 'relative' },

  // ÌòÑÏû¨ Ï£ºÏÜå Î∞∞ÏßÄ
  addressBadge: {
    alignSelf: 'center',
    maxWidth: '92%',
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 14,
    backgroundColor: 'rgba(255,255,255,0.92)',
    borderColor: 'rgba(0,0,0,0.06)',
    borderWidth: 1,
    marginBottom: 6
  },
  addressBadgeText: { color: '#2C3E50', fontWeight: '700' },

  bottomUnderlay: {
    position: 'absolute',
    left: 0, right: 0, bottom: 0,
    backgroundColor: '#FFFFFF',
    zIndex: 0
  },

  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },

  mapContainer: {
    flex: 1,
    margin: 8,
    marginTop: 0,
    marginBottom: 0,
    borderRadius: 15,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 5,
    zIndex: 1
  },
  map: { flex: 1 },

  // ‚úÖ ÌûåÌä∏ Ïä§ÌÉÄÏùº (Ï°∞Í∏à ÏïÑÎûò + Î∞ùÏùÄ ÌöåÏÉâ)
  destHintWrap: { alignItems: 'center', marginTop: 10, marginBottom: 6 },
  destHintText: { color: '#9AA0A6', fontWeight: '700' },

  dogInfoBanner: {
    backgroundColor: '#4ECDC4',
    paddingHorizontal: 15,
    paddingVertical: 8,
    marginHorizontal: 10,
    borderRadius: 20,
    marginBottom: 5,
    zIndex: 1
  },
  dogInfoText: { color: '#FFFFFF', fontSize: 14, fontWeight: 'bold', textAlign: 'center' },

  runningInfo: {
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 25,
    borderTopRightRadius: 25,
    paddingHorizontal: 18,
    paddingTop: 20,
    paddingBottom: 40,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 5,
    zIndex: 2,
    marginTop: 15
  },
  panelTopRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 8
  },

  // Í∞ÄÏö¥Îç∞ Î≤ÑÌäº Î¨∂Ïùå
  topRowActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },

  miniSelectDogBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#EEF3F7',
    borderRadius: 12,
    alignSelf: 'flex-start'
  },
  miniSelectDogTxt: { color: '#2C3E50', fontWeight: '800' },
  miniBadge: {
    position: 'absolute',
    top: -6, right: -6,
    width: 20, height: 20, borderRadius: 10,
    alignItems: 'center', justifyContent: 'center',
    backgroundColor: '#FF6B6B'
  },
  miniBadgeTxt: { color: '#FFF', fontSize: 11, fontWeight: '800' },

  manageBtn: {
    alignSelf: 'flex-end',
    backgroundColor: '#F0F1F2',
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 12
  },
  manageBtnText: { color: '#2C3E50', fontWeight: '700' },

  timerContainer: { alignItems: 'center', marginBottom: 10 },
  timerText: { fontSize: 44, fontWeight: 'bold', color: '#2C3E50' },
  timerLabel: { fontSize: 16, color: '#2C3E50', opacity: 0.75, marginTop: 5 },

  controlButtons: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12,
    gap: 10
  },
  runButton: { width: 92, height: 92, borderRadius: 46, justifyContent: 'center', alignItems: 'center' },
  runButtonText: { fontSize: 16, color: '#FFFFFF', fontWeight: 'bold' },

  resetButton: { backgroundColor: '#95A5A6', borderRadius: 12, paddingHorizontal: 16, paddingVertical: 12 },
  resetButtonText: { fontSize: 14, color: '#FFFFFF', fontWeight: 'bold' },

  selectedChipRow: { flexDirection: 'row', alignItems: 'center', gap: 8 },
  selectedChip: { flexDirection:'row', alignItems:'center', paddingHorizontal: 12, paddingVertical: 6, backgroundColor: '#F0F1F2', borderRadius: 14 },
  selectedChipText: { color: '#2C3E50', fontWeight: '700' },

  statsContainer: { flexDirection: 'row', justifyContent: 'space-around', paddingTop: 18, borderTopWidth: 1, borderTopColor: '#E0E0E0' },
  statItem: { alignItems: 'center' },
  statValue: { fontSize: 18, fontWeight: 'bold', color: '#2C3E50' },
  statLabel: { fontSize: 12, color: '#7F8C8D', marginTop: 5 },

  completedBanner: { backgroundColor: '#27AE60', borderRadius: 15, padding: 15, marginTop: 20, alignItems: 'center' },
  completedText: { fontSize: 18, fontWeight: 'bold', color: '#FFFFFF', marginBottom: 5 },
  completedSubtext: { fontSize: 14, color: '#FFFFFF', opacity: 0.9 },

  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center', padding: 16 },
  modalContent: { backgroundColor: '#FFFFFF', borderRadius: 20, padding: 20, width: '92%', maxHeight: '85%' },
  modalTitle: { fontSize: 22, fontWeight: 'bold', color: '#2C3E50', textAlign: 'center', marginBottom: 12 },

  activityPickBtn: {
    flex: 1,
    backgroundColor: '#2D9CDB',
    paddingVertical: 14,
    borderRadius: 12,
    alignItems: 'center'
  },
  activityPickTxt: { color: '#FFF', fontWeight: '800' },

  pickRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 10,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#E0E0E0',
    marginBottom: 8
  },
  pickRowSelected: { backgroundColor: '#ECF8FF', borderColor: '#2D9CDB' },
  checkbox: {
    width: 22, height: 22, marginRight: 10, borderRadius: 6,
    borderWidth: 2, borderColor: '#B0BEC5', alignItems: 'center', justifyContent: 'center'
  },
  checkboxChecked: { backgroundColor: '#2D9CDB', borderColor: '#2D9CDB' },
  checkboxMark: { color: '#FFFFFF', fontWeight: '900' },
  pickName: { fontSize: 16, color: '#2C3E50', fontWeight: '700' },
  pickSub: { fontSize: 12, color: '#7F8C8D', marginTop: 2 },
  pickEdit: { paddingHorizontal: 10, paddingVertical: 6, backgroundColor: '#F0F1F2', borderRadius: 8, marginLeft: 8 },
  pickEditText: { color: '#2C3E50', fontWeight: '700', fontSize: 12 },

  modalButtons: { flexDirection: 'row', gap: 10, marginTop: 14, alignItems: 'center', justifyContent: 'flex-end' },
  modalGhostButton: { paddingVertical: 12, paddingHorizontal: 14, borderRadius: 10, backgroundColor: '#F0F1F2' },
  modalGhostText: { color: '#2C3E50', fontWeight: '700' },
  modalCancelButton: { flex: 1, paddingVertical: 14, borderRadius: 10, backgroundColor: '#95A5A6', alignItems: 'center' },
  modalCancelText: { color: '#FFFFFF', fontSize: 16, fontWeight: 'bold' },
  modalSaveButton: { paddingVertical: 14, paddingHorizontal: 18, borderRadius: 10, backgroundColor: '#27AE60', alignItems: 'center' },
  modalSaveText: { color: '#FFFFFF', fontSize: 16, fontWeight: 'bold' },

  modalForm: { maxHeight: 420 },
  inputGroup: { marginBottom: 16 },
  inputLabel: { fontSize: 14, fontWeight: 'bold', color: '#2C3E50', marginBottom: 6 },
  textInput: { borderWidth: 1, borderColor: '#E0E0E0', borderRadius: 10, paddingHorizontal: 14, paddingVertical: 12, fontSize: 15, backgroundColor: '#F8F9FA' },

  breedContainer: { flexDirection: 'row', gap: 8, paddingVertical: 5 },
  breedButton: { paddingHorizontal: 14, paddingVertical: 8, borderRadius: 20, backgroundColor: '#F8F9FA', borderWidth: 1, borderColor: '#E0E0E0' },
  breedButtonSelected: { backgroundColor: '#FF6B6B', borderColor: '#FF6B6B' },
  breedButtonText: { fontSize: 13, color: '#7F8C8D' },
  breedButtonTextSelected: { color: '#FFFFFF', fontWeight: 'bold' },

  activityContainer: { flexDirection: 'row', gap: 10 },
  activityButton: { flex: 1, paddingVertical: 12, borderRadius: 10, backgroundColor: '#F8F9FA', borderWidth: 1, borderColor: '#E0E0E0', alignItems: 'center' },
  activityButtonSelected: { backgroundColor: '#4ECDC4', borderColor: '#4ECDC4' },
  activityButtonText: { fontSize: 14, color: '#7F8C8D' },
  activityButtonTextSelected: { color: '#FFFFFF', fontWeight: 'bold' },

  dogChipRow: { flexDirection: 'row', alignItems: 'center', gap: 8 },
  dogChip: { flexDirection:'row', alignItems:'center', paddingHorizontal: 12, paddingVertical: 8, backgroundColor: '#F8F9FA', borderColor: '#E0E0E0', borderWidth: 1, borderRadius: 18 },
  dogChipActive: { backgroundColor: '#27AE60', borderColor: '#27AE60' },
  dogChipText: { color: '#2C3E50', fontSize: 13 },
  dogChipTextActive: { color: '#FFFFFF', fontWeight: '700' },
  dogChipAdd: { paddingHorizontal: 14, paddingVertical: 8, backgroundColor: '#FF6B6B', borderRadius: 18 },
  dogChipAddText: { color: '#FFFFFF', fontWeight: '700', fontSize: 13 },

  modalDeleteButton: { flex: 1, paddingVertical: 14, borderRadius: 10, backgroundColor: '#E74C3C', alignItems: 'center' },
  modalDeleteText: { color: '#FFFFFF', fontSize: 16, fontWeight: 'bold' }
});
